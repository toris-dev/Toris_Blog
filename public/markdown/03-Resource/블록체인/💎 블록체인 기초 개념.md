# 💎 블록체인 기초 개념

> 블록체인 개발을 위한 핵심 개념과 용어 정리

## 🧱 블록체인 기본 구조

### 블록체인이란?

블록체인은 거래 정보를 담은 **블록(Block)**들이 **체인(Chain)** 형태로 연결된 분산 데이터베이스입니다.

```
[블록 1] → [블록 2] → [블록 3] → [블록 4] → ...
```

각 블록은 다음 정보를 포함합니다:

- **해시값**: 블록의 고유 식별자
- **이전 블록 해시**: 체인 연결을 위한 포인터
- **거래 데이터**: 실제 거래 정보들
- **타임스탬프**: 블록 생성 시간
- **논스**: 작업증명을 위한 숫자

## 🔑 핵심 개념들

### 1. 스마트 컨트랙트 (Smart Contract)

블록체인 네트워크에서 자동으로 실행되는 프로그램

```solidity
contract SimpleContract {
    string public message;

    function setMessage(string memory _message) public {
        message = _message;
    }
}
```

**특징:**

- 조건이 충족되면 자동 실행
- 중간자 없이 거래 가능
- 투명하고 변경 불가능

### 2. 토큰 (Token)

블록체인 네트워크에서 가치를 나타내는 디지털 자산

#### ERC-20 (Fungible Token)

- 서로 교환 가능한 토큰
- 코인, 포인트, 주식 등에 활용
- 예: USDT, LINK, UNI

#### ERC-721 (Non-Fungible Token, NFT)

- 고유하고 교환 불가능한 토큰
- 디지털 아트, 게임 아이템, 인증서 등에 활용
- 예: CryptoPunks, Bored Ape

#### ERC-1155 (Multi Token)

- 여러 토큰 타입을 하나의 컨트랙트에서 관리
- 게임에서 다양한 아이템을 관리할 때 유용

### 3. 지갑 (Wallet)

블록체인 자산을 관리하는 도구

```typescript
// 지갑 연결 예제
const connectWallet = async () => {
  if (window.ethereum) {
    const accounts = await window.ethereum.request({
      method: "eth_requestAccounts",
    });
    return accounts[0];
  }
};
```

**지갑 종류:**

- **핫 월렛**: 인터넷 연결 (MetaMask, WalletConnect)
- **콜드 월렛**: 오프라인 저장 (Ledger, Trezor)

### 4. 가스 (Gas)

트랜잭션 실행을 위한 수수료

```typescript
// 가스 설정 예제
const transaction = {
  to: contractAddress,
  data: contractData,
  gasLimit: 21000, // 최대 가스 사용량
  gasPrice: "20000000000", // 가스 가격 (20 Gwei)
};
```

**가스 구성:**

- **Gas Limit**: 트랜잭션에서 사용할 최대 가스량
- **Gas Price**: 가스당 지불할 가격 (Gwei 단위)
- **Gas Fee = Gas Used × Gas Price**

## 🌍 주요 블록체인 네트워크

### 이더리움 (Ethereum)

- **특징**: 스마트 컨트랙트 플랫폼의 선구자
- **언어**: Solidity
- **합의 방식**: Proof of Stake (PoS)
- **장점**: 가장 큰 생태계, 다양한 DeFi/NFT 프로젝트
- **단점**: 높은 가스비, 느린 처리 속도

### 폴리곤 (Polygon)

- **특징**: 이더리움 Layer 2 솔루션
- **언어**: Solidity (이더리움 호환)
- **합의 방식**: Proof of Stake
- **장점**: 낮은 가스비, 빠른 처리 속도
- **사용 사례**: 게임, NFT, DeFi

### 바이낸스 스마트 체인 (BSC)

- **특징**: 바이낸스에서 개발한 고성능 블록체인
- **언어**: Solidity
- **장점**: 저렴한 수수료, 빠른 거래
- **사용 사례**: DeFi, 거래소 연계 서비스

## 🛠️ 개발 도구

### 1. 개발 환경

```bash
# Hardhat - 이더리움 개발 환경
npm install --save-dev hardhat

# Truffle - 스마트 컨트랙트 개발 프레임워크
npm install -g truffle

# Remix - 브라우저 기반 IDE
# https://remix.ethereum.org
```

### 2. 테스트 네트워크

| 네트워크 | 메인넷  | 테스트넷 | 용도                                        |
| -------- | ------- | -------- | ------------------------------------------- |
| Ethereum | Mainnet | Sepolia  | 실제 서비스 (참고: Goerli는 지원 종료 예정) |
| Polygon  | Mainnet | Amoy     | 저렴한 대안 (참고: Mumbai는 지원 종료 예정) |
| BSC      | Mainnet | Testnet  | 빠른 거래                                   |

### 3. 개발 라이브러리

```javascript
// ethers.js - 이더리움과 상호작용
import { ethers } from "ethers";

// web3.js - 이더리움 JavaScript API
import Web3 from "web3";

// OpenZeppelin - 보안 검증된 컨트랙트
// (Solidity 파일 내에서 사용)
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
```

## 📊 실전 활용 예제

### DeFi (탈중앙화 금융)

```solidity
// 간단한 스테이킹 컨트랙트
contract SimpleStaking {
    mapping(address => uint256) public stakes;
    mapping(address => uint256) public rewards;

    function stake(uint256 amount) public {
        // 실제 구현에서는 ERC20 토큰의 transferFrom 함수를 호출하여
        // 사용자의 토큰을 컨트랙트로 안전하게 전송해야 합니다.
        // 예: stakingToken.transferFrom(msg.sender, address(this), amount);
        stakes[msg.sender] += amount;
    }

    function calculateReward(address user) public view returns (uint256) {
        // 참고: 실제 이자 계산은 스테이킹 기간 등을 고려한 복잡한 로직이 필요합니다.
        // 이것은 단순 계산 예시입니다.
        return stakes[user] * 10 / 100; // 예: 스테이킹된 양의 10%를 리워드로 계산
    }
}
```

### NFT 마켓플레이스

```solidity
contract NFTMarketplace {
    struct Listing {
        uint256 price;
        address seller;
        bool active;
    }

    mapping(uint256 => Listing) public listings;

    function listNFT(uint256 tokenId, uint256 price) public {
        listings[tokenId] = Listing(price, msg.sender, true);
    }

    function buyNFT(uint256 tokenId) public payable {
        Listing memory listing = listings[tokenId];
        require(msg.value >= listing.price, "Insufficient payment");
        require(listing.active, "Listing is not active");

        // 1. 리스팅 비활성화
        listings[tokenId].active = false;

        // 2. 판매자에게 대금 전송
        (bool success, ) = listing.seller.call{value: msg.value}("");
        require(success, "Payment failed");

        // 3. 구매자에게 NFT 전송
        // 실제 구현에서는 NFT 컨트랙트 주소와 상호작용해야 합니다.
        // 예: nftContract.transferFrom(listing.seller, msg.sender, tokenId);
    }
}
```

### 게임 경제 시스템

```solidity
contract GameEconomy {
    // 게임 내 재화
    IERC20 public gameToken;
    IERC721 public gameItems;

    // 플레이어 레벨과 경험치
    mapping(address => uint256) public playerLevel;
    mapping(address => uint256) public experience;

    function completeQuest(address player, uint256 expReward, uint256 tokenReward) public {
        experience[player] += expReward;
        gameToken.mint(player, tokenReward);

        // 레벨업 체크
        if (experience[player] >= getRequiredExp(playerLevel[player])) {
            playerLevel[player]++;
        }
    }

    function getRequiredExp(uint256 level) internal pure returns (uint256) {
        // 간단한 예: 레벨업에 필요한 경험치는 레벨의 제곱
        return (level + 1) * (level + 1) * 100;
    }
}
```

## 🔒 보안 고려사항

### 1. 스마트 컨트랙트 보안

```solidity
// ❌ 나쁜 예: Reentrancy 공격 취약
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount);
    msg.sender.call{value: amount}(""); // 외부 호출
    balances[msg.sender] -= amount;     // 잔액 업데이트
}

// ✅ 좋은 예: Checks-Effects-Interactions 패턴
function withdrawSecure(uint256 amount) public {
    uint256 balance = balances[msg.sender];
    require(balance >= amount, "Insufficient balance");
    balances[msg.sender] = balance - amount; // 먼저 잔액 업데이트 (Effects)
    (bool success, ) = msg.sender.call{value: amount}(""); // 그 다음 외부 호출 (Interactions)
    require(success, "Transfer failed.");
}
```

### 2. 일반적인 취약점

| 취약점           | 설명            | 대응방안                    |
| ---------------- | --------------- | --------------------------- |
| Reentrancy       | 재귀 호출 공격  | ReentrancyGuard 사용        |
| Integer Overflow | 정수 오버플로우 | SafeMath 또는 Solidity 0.8+ |
| Access Control   | 권한 관리 부실  | OpenZeppelin Access Control |
| Front Running    | 거래 순서 조작  | Commit-Reveal 스킴          |

### 3. 베스트 프랙티스

```solidity
// 접근 제어
import "@openzeppelin/contracts/access/Ownable.sol";

contract SecureContract is Ownable {
    // 오직 소유자만 호출 가능
    function sensitiveFunction() public onlyOwner {
        // 중요한 로직
    }
}

// 상태 변경 검증
modifier validAmount(uint256 amount) {
    require(amount > 0, "Amount must be positive");
    require(amount <= maxAmount, "Amount exceeds limit");
    _;
}
```

## 📈 트렌드와 미래

### 1. Layer 2 솔루션

- **Polygon**: 이더리움 사이드체인
- **Arbitrum**: Optimistic Rollup
- **zkSync**: Zero-Knowledge Rollup

### 2. 크로스체인 (Cross-chain)

- 서로 다른 블록체인 간 자산 이동
- 브릿지 프로토콜 활용
- 상호 운용성 증대

### 3. Web3 생태계

- **DeFi**: 탈중앙화 금융 서비스
- **NFT**: 디지털 자산과 소유권
- **DAO**: 탈중앙화 자율 조직
- **GameFi**: 블록체인 게임과 경제

### 4. 지속가능성

- **Proof of Stake**: 에너지 효율적 합의
- **Carbon Neutral**: 탄소 중립 블록체인
- **Green Mining**: 친환경 채굴

## 🎯 학습 로드맵

### 초급 (1-2개월)

1. 블록체인 기본 개념 이해
2. 메타마스크 사용법 익히기
3. 간단한 DApp 체험
4. Solidity 기초 문법

### 중급 (3-6개월)

1. 스마트 컨트랙트 개발
2. 프론트엔드 연동 (web3.js, ethers.js)
3. 테스트 작성과 디버깅
4. 보안 모범 사례 학습

### 고급 (6개월+)

1. 복잡한 DeFi 프로토콜 구현
2. 가스 최적화 기법
3. 크로스체인 개발
4. 프로덕션 배포와 운영

---

블록체인 개발의 핵심은 **탈중앙화**와 **투명성**입니다. 이 기반 위에서 혁신적인 서비스를 만들어가세요! 🚀

#블록체인 #기초개념 #스마트컨트랙트 #DeFi #NFT #web3 #학습가이드
