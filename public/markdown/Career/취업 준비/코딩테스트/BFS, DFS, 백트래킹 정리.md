---
title: [Career] BFS, DFS, ë°±íŠ¸ë˜í‚¹ ì •ë¦¬
date: 2025-07-09T16:55:19.894Z
slug: bfs-dfs-ë°±íŠ¸ë˜í‚¹-ì •ë¦¬
category: Career
tags: Career, CodingTest
---

## DFS (Depth-first search, DFS)

ê·¸ë˜í”„ë¥¼ íƒìƒ‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ í•˜ë‚˜ë¡œ, ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° í•˜ë‚˜ì˜ ë°©í–¥ì„ ì¡ì•„ ëê¹Œì§€ íƒìƒ‰í•œ í›„ ë§ˆì§€ë§‰ ë¶„ê¸°ì ìœ¼ë¡œ ëŒì•„ì™€ ë‹¤ì‹œ ë‹¤ë¥¸ ë°©í–¥ìœ¼ë¡œ ëê¹Œì§€ íƒìƒ‰ì„ ë°˜ë³µí•˜ëŠ” ë°©ì‹.

1. í•œ ë¶„ê¸°ë¥¼ íƒìƒ‰í•œ í›„, ë‹¤ìŒ ë¶„ê¸°ë¡œ ë„˜ì–´ì„œê¸° ì „ì— í•´ë‹¹ ë¶„ê¸°ë¥¼ ì™„ë²½í•˜ê²Œ íƒìƒ‰í•œë‹¤.
2. ë” ì´ìƒ íƒìƒ‰ì´ ë¶ˆê°€ëŠ¥í•œ ìƒíƒœê°€ ë˜ë©´ ì´ì „ ë¶„ê¸°ë¡œ ëŒì•„ì™€ ë‹¤ìŒ ë¶„ê¸°ë¥¼ íƒìƒ‰í•œë‹¤.
3. ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•œ í›„, íƒìƒ‰ì„ ì¢…ë£Œí•œë‹¤.

**ìŠ¤íƒ ìë£Œêµ¬ì¡°ë‚˜ ì¬ê·€ë¥¼ í†µí•´ì„œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.**

- íš¨ìœ¨ì€ ìŠ¤íƒì´ ì¢€ ë” ì¢‹ì§€ë§Œ ì¬ê·€ê°€ ë” êµ¬í˜„í•˜ê¸° ì‰½ê³  ë¹¨ë¼ì„œ ì¼ë°˜ì ìœ¼ë¡œ ì¬ê·€ë¥¼ í†µí•´ì„œ êµ¬í˜„í•œë‹¤.

ìŠ¤íƒì„ í™œìš©í•œ DFS (Iteractive DFS)

1. ì‹œì‘ ì •ì ì„ ìŠ¤íƒì— ì‚½ì…í•œë‹¤.
2. ìŠ¤íƒì—ì„œ í•˜ë‚˜ì˜ ì •ì ì„ êº¼ë‚¸ë‹¤.
3. ìŠ¤íƒì—ì„œ êº¼ë‚¸ ì •ì ì´ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì ì´ë¼ë©´, ë°©ë¬¸ í‘œì‹œ í›„ ì´ì›ƒ ì •ì ë“¤ì„ ìŠ¤íƒì— ì‚½ì…í•œë‹¤.
4. ìŠ¤íƒì— ë‹´ê¸´ ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ 2-3ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

```js
function dfs(graph, start, visited) {
  const stack = [];
  stack.push(start);
  while (stack.length) {
    let v = stack.pop();
    if (!visited[v]) {
      console.log(v);
      visited[v] = true;
      for (let node of graph[v]) {
        if (!visited[node]) {
          stack.push(node);
        }
      }
    }
  }
}

const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
```

ì¬ê·€í•¨ìˆ˜ë¥¼ í™œìš©í•œ DFS (Recursive DFS)

1. ì‹œì‘ ì •ì ì„ ì¸ìë¡œ ë°›ëŠ” DFS í•¨ìˆ˜ë¥¼ ì •ì˜ í•œë‹¤.
2. í˜„ì¬ ì •ì ì„ ë°©ë¬¸ ì²˜ë¦¬ í•œë‹¤.
3. í˜„ì¬ ì •ì ê³¼ ì—°ê²°ëœ ì¸ì ‘ ì •ì ë“¤ì„ í™•ì¸í•œë‹¤.
4. ì¸ì ‘ ì •ì  ì¤‘ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì ì„ ì¬ê·€ì ìœ¼ë¡œ DFSì— í˜¸ì¶œí•œë‹¤.
   ì¬ê·€ í•¨ìˆ˜ëŠ” í•­ìƒ íƒˆì¶œ ì¡°ê±´ì´ ìˆì–´ì•¼ í•¨ì„ ê¸°ì–µ!!

```js
const dfs = (graph, v, visited) => {
  visited[v] = true;
  console.log(v);

  for (let node of graph[v]) {
    if (!visited[node]) {
      dfs(graph, node, visited);
    }
  }
};

const graph = [[1, 2, 4], [0, 5], [0, 5], [4], [0, 3], [1, 2]];
const visited = Array(7).fill(false);

dfs(graph, 0, visited);
```

### DFS ë¥¼ í™œìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°

**ğŸ˜ê²½ë¡œì˜ íŠ¹ì§•ì„ ì €ì¥í•´ ë‘¬ì•¼ í•˜ëŠ” ë¬¸ì œ**

- ì˜ˆë¥¼ ë“¤ì–´ ê° ì •ì ì— ìˆ«ìê°€ ì í˜€ìˆê³  aë¶€í„° bê¹Œì§€ ê°€ëŠ” ê²½ë¡œë¥¼ êµ¬í•˜ëŠ”ë° ê²½ë¡œì— ê°™ì€ ìˆ«ìê°€ ìˆìœ¼ë©´ ì•ˆëœë‹¤ëŠ” ë¬¸ì œì™€ ê°™ì´ ê°ê°ì˜ ê²½ë¡œë§ˆë‹¤ íŠ¹ì§•ì„ ì €ì¥í•´ì•¼ í•  ë•Œ FSë¥¼ ì£¼ë¡œ ì‚¬ìš©í•œë‹¤.

**ğŸ˜ê²€ìƒ‰ ëŒ€ìƒ ê·¸ë˜í”„ê°€ í° ê²½ìš° (ë…¸ë“œì™€ ê°„ì„ ì´ ë§ì€ ê²½ìš°)**
ë‹¨ì§€ í˜„ ê²½ë¡œìƒì˜ ì •ì ë“¤ë§Œì„ ê¸°ì–µí•˜ë©´ ë˜ë¯€ë¡œ ì €ì¥ ê³µê°„ì˜ ìˆ˜ìš”ê°€ ë¹„êµì  ì ê³ , ëª©í‘œí•œ ì •ì ì´ ê¹Šì€ ë‹¨ê³„ì— ìˆìœ¼ë©´ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë£¨íŠ¸ë¥¼ ë¹¨ë¦¬ êµ¬í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆë‹¤.

**ğŸ˜ë°±íŠ¸ë˜í‚¹ VS DFS**
ë°±íŠ¸ë˜í‚¹ = ë” ì´ìƒ íƒìƒ‰í•  í•„ìš”ê°€ ì—†ë‹¤ë©´, ì•ì„  ì„ íƒìœ¼ë¡œ ë˜ëŒì•„ì™€ íƒìƒ‰ì„ ë°˜ë³µ
DFS = ê·¸ë˜í”„ì˜ íƒìƒ‰ ê¸°ë²•ìœ¼ë¡œ ë‹¨ìˆœí•˜ê²Œ ì´ì–´ì§„ ê¸¸ì„ ì­‰ ë°˜ë³µí•˜ëŠ” ê³¼ì •

ì´ ë‘˜ì€ ë—„ë ˆì•¼ ë—„ ìˆ˜ ì—†ë‹¤... DFS ì—ì„œ ë°±íŠ¸ë˜í‚¹ì„ ìì£¼ ì‚¬ìš©.

## ë°±íŠ¸ë˜í‚¹ (Backtracking)

ë°±íŠ¸ë˜í‚¹ì€ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê°€ëŠ¥í•œ ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•˜ë˜, ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ì´ì „ ë‹¨ê³„ë¡œ ëŒì•„ê°€ì„œ ë‹¤ë¥¸ ê²½ë¡œë¥¼ ì‹œë„í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•ì…ë‹ˆë‹¤.

### ë°±íŠ¸ë˜í‚¹ì˜ í•µì‹¬ ê°œë…

1. **ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ì¦‰ì‹œ ì¤‘ë‹¨**: í˜„ì¬ ê²½ë¡œê°€ í•´ë‹µì´ ë  ìˆ˜ ì—†ë‹¤ê³  íŒë‹¨ë˜ë©´ ì¦‰ì‹œ ë˜ëŒì•„ê°
2. **ìƒíƒœ ë³µì›**: ì´ì „ ë‹¨ê³„ë¡œ ëŒì•„ê°ˆ ë•Œ ë³€ê²½í–ˆë˜ ìƒíƒœë¥¼ ì›ë˜ëŒ€ë¡œ ë³µì›
3. **ê°€ì§€ì¹˜ê¸° (Pruning)**: ë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ ì¤„ì—¬ íš¨ìœ¨ì„± í–¥ìƒ

### ë°±íŠ¸ë˜í‚¹ì˜ ë™ì‘ ê³¼ì •

1. í˜„ì¬ ìƒíƒœì—ì„œ ê°€ëŠ¥í•œ ì„ íƒì§€ë¥¼ ì‹œë„
2. ì„ íƒí•œ ê²½ë¡œê°€ ìœ íš¨í•œì§€ ê²€ì‚¬ (ì œì•½ ì¡°ê±´ í™•ì¸)
3. ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì´ì „ ìƒíƒœë¡œ ë˜ëŒì•„ê° (ë°±íŠ¸ë˜í‚¹)
4. ìœ íš¨í•˜ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰
5. ëª©í‘œì— ë„ë‹¬í•˜ê±°ë‚˜ ëª¨ë“  ê²½ìš°ë¥¼ íƒìƒ‰í•  ë•Œê¹Œì§€ ë°˜ë³µ

### ë°±íŠ¸ë˜í‚¹ êµ¬í˜„ ì˜ˆì œ

#### ì˜ˆì œ 1: N-Queen ë¬¸ì œ

NÃ—N ì²´ìŠ¤íŒì— Nê°œì˜ í€¸ì„ ì„œë¡œ ê³µê²©í•  ìˆ˜ ì—†ë„ë¡ ë°°ì¹˜í•˜ëŠ” ë¬¸ì œ

```js
function solveNQueens(n) {
  const result = [];
  const board = Array(n)
    .fill()
    .map(() => Array(n).fill('.'));

  function isValid(row, col) {
    // ê°™ì€ ì—´ì— í€¸ì´ ìˆëŠ”ì§€ í™•ì¸
    for (let i = 0; i < row; i++) {
      if (board[i][col] === 'Q') return false;
    }

    // ì™¼ìª½ ìœ„ ëŒ€ê°ì„  í™•ì¸
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (board[i][j] === 'Q') return false;
    }

    // ì˜¤ë¥¸ìª½ ìœ„ ëŒ€ê°ì„  í™•ì¸
    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
      if (board[i][j] === 'Q') return false;
    }

    return true;
  }

  function backtrack(row) {
    // ëª¨ë“  í–‰ì— í€¸ì„ ë°°ì¹˜í–ˆìœ¼ë©´ ê²°ê³¼ì— ì¶”ê°€
    if (row === n) {
      result.push(board.map((r) => r.join('')));
      return;
    }

    // í˜„ì¬ í–‰ì˜ ê° ì—´ì— í€¸ì„ ë°°ì¹˜ ì‹œë„
    for (let col = 0; col < n; col++) {
      if (isValid(row, col)) {
        board[row][col] = 'Q'; // í€¸ ë°°ì¹˜
        backtrack(row + 1); // ë‹¤ìŒ í–‰ìœ¼ë¡œ
        board[row][col] = '.'; // ë°±íŠ¸ë˜í‚¹: ìƒíƒœ ë³µì›
      }
    }
  }

  backtrack(0);
  return result;
}

console.log(solveNQueens(4));
```

#### ì˜ˆì œ 2: ë¶€ë¶„ì§‘í•© í•© ë¬¸ì œ

ì£¼ì–´ì§„ ë°°ì—´ì—ì„œ í•©ì´ íŠ¹ì • ê°’ì´ ë˜ëŠ” ë¶€ë¶„ì§‘í•©ì„ ì°¾ëŠ” ë¬¸ì œ

```js
function findSubsetSum(arr, target) {
  const result = [];

  function backtrack(index, currentSum, path) {
    // ëª©í‘œ í•©ì— ë„ë‹¬í•œ ê²½ìš°
    if (currentSum === target) {
      result.push([...path]);
      return;
    }

    // ë°°ì—´ì˜ ëì— ë„ë‹¬í•˜ê±°ë‚˜ í•©ì´ ëª©í‘œë¥¼ ì´ˆê³¼í•œ ê²½ìš°
    if (index >= arr.length || currentSum > target) {
      return;
    }

    // í˜„ì¬ ì›ì†Œë¥¼ í¬í•¨í•˜ëŠ” ê²½ìš°
    path.push(arr[index]);
    backtrack(index + 1, currentSum + arr[index], path);

    // í˜„ì¬ ì›ì†Œë¥¼ í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²½ìš° (ë°±íŠ¸ë˜í‚¹)
    path.pop();
    backtrack(index + 1, currentSum, path);
  }

  backtrack(0, 0, []);
  return result;
}

const arr = [2, 3, 6, 7];
const target = 7;
console.log(findSubsetSum(arr, target)); // [[2, 2, 3], [7]]
```

#### ì˜ˆì œ 3: ìˆœì—´ ìƒì„±

ì£¼ì–´ì§„ ë°°ì—´ì˜ ëª¨ë“  ìˆœì—´ì„ ìƒì„±í•˜ëŠ” ë¬¸ì œ

```js
function permute(nums) {
  const result = [];
  const used = Array(nums.length).fill(false);

  function backtrack(path) {
    // ëª¨ë“  ì›ì†Œë¥¼ ì‚¬ìš©í–ˆìœ¼ë©´ ê²°ê³¼ì— ì¶”ê°€
    if (path.length === nums.length) {
      result.push([...path]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      if (used[i]) continue; // ì´ë¯¸ ì‚¬ìš©í•œ ì›ì†ŒëŠ” ê±´ë„ˆë›°ê¸°

      // í˜„ì¬ ì›ì†Œë¥¼ ê²½ë¡œì— ì¶”ê°€
      path.push(nums[i]);
      used[i] = true;

      // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰
      backtrack(path);

      // ë°±íŠ¸ë˜í‚¹: ìƒíƒœ ë³µì›
      path.pop();
      used[i] = false;
    }
  }

  backtrack([]);
  return result;
}

console.log(permute([1, 2, 3]));
// [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

### ë°±íŠ¸ë˜í‚¹ì„ í™œìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°

- **ì œì•½ ì¡°ê±´ì´ ìˆëŠ” ì¡°í•©/ìˆœì—´ ë¬¸ì œ**: N-Queen, ìŠ¤ë„ì¿ , ë¶€ë¶„ì§‘í•© í•© ë“±
- **ëª¨ë“  ê°€ëŠ¥í•œ í•´ë¥¼ ì°¾ì•„ì•¼ í•˜ëŠ” ë¬¸ì œ**: ì™„ì „ íƒìƒ‰ì´ í•„ìš”í•œ ê²½ìš°
- **ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ì¦‰ì‹œ ì¤‘ë‹¨í•  ìˆ˜ ìˆëŠ” ë¬¸ì œ**: ê°€ì§€ì¹˜ê¸°ê°€ ê°€ëŠ¥í•œ ê²½ìš°

### ë°±íŠ¸ë˜í‚¹ì˜ ì‹œê°„ ë³µì¡ë„

- ìµœì•…ì˜ ê²½ìš°: O(b^d) (bëŠ” ë¶„ê¸° ìˆ˜, dëŠ” ê¹Šì´)
- ê°€ì§€ì¹˜ê¸°ë¥¼ í†µí•´ ì‹¤ì œë¡œëŠ” í›¨ì”¬ ì ì€ ê²½ìš°ë¥¼ íƒìƒ‰
- ê³µê°„ ë³µì¡ë„: O(d) (ì¬ê·€ í˜¸ì¶œ ìŠ¤íƒì˜ ê¹Šì´)

### DFSì™€ ë°±íŠ¸ë˜í‚¹ì˜ ì°¨ì´ì 

| íŠ¹ì§•          | DFS                    | ë°±íŠ¸ë˜í‚¹                        |
| ------------- | ---------------------- | ------------------------------- |
| **ëª©ì **      | ê·¸ë˜í”„ íƒìƒ‰            | ì œì•½ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í•´ ì°¾ê¸°    |
| **ìƒíƒœ ë³µì›** | í•„ìš” ì—†ìŒ              | í•„ìˆ˜ (ì´ì „ ìƒíƒœë¡œ ë˜ëŒì•„ê°)     |
| **ê°€ì§€ì¹˜ê¸°**  | ì„ íƒì                  | í•µì‹¬ (ì¡°ê±´ ë¶ˆë§Œì¡± ì‹œ ì¦‰ì‹œ ì¤‘ë‹¨) |
| **ì ìš© ë¬¸ì œ** | ê²½ë¡œ ì°¾ê¸°, ì—°ê²°ì„± í™•ì¸ | N-Queen, ìŠ¤ë„ì¿ , ì¡°í•© ë¬¸ì œ      |

### ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (Breadth-first search, BFS)

ê°€ì¥ ë¨¼ì € ì‹œì‘ ì •ì ì„ ë°©ë¬¸í•œ í›„, ê·¸ ì‹œì‘ ì¥ì ê³¼ ì¸ì ‘í•œ ëª¨ë“  ì •ì ë“¤ì„ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰í•´ë‚˜ê°€ëŠ” ë°©ë²•

ì¶œë°œì ì„ ë¨¼ì € íì— ë„£ê³ , íê°€ ë¹Œ ë•Œê¹Œì§€ ì•„ë˜ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

1. íì— ì €ì¥ëœ ì •ì ì„ í•˜ë‚˜ Deueue í•œë‹¤.
2. ê·¸ë¦¬ê³  ëº€ ì •ì ê³¼ ì—°ê²°ëœ ëª¨ë“  ì •ì ì„ íì— ë„£ëŠ”ë‹¤.

BFS êµ¬í˜„ í•¨ìˆ˜

1. íƒìƒ‰ ìŠ¤íƒ, ë°©ë¬¸ ë°°ì—´ì„ ìƒì„±
2. íƒìƒ‰ì„ ì‹œì‘í•˜ëŠ” ì •ì ì„ íƒìƒ‰ ìŠ¤íƒì— ìŒ“ëŠ”ë‹¤.
3. íƒìƒ‰ ìŠ¤íƒì˜ length ê°€ 0 ì´ ì•„ë‹ ë•Œ ê¹Œì§€ ì•„ë˜ ê³¼ì •ì„ ë°˜ë³µ
   1. ìŠ¤íƒ ìµœìƒë‹¨ì— ìˆëŠ” ê²ƒì„ ì—†ì• ê³ , ì´ë¥¼ íƒìƒ‰í•œë‹¤.
   2. íƒìƒ‰ ì‹œì— ë°©ë¬¸ í–ˆëŠ”ì§€ ì²´í¬, í–ˆë‹¤ë©´ íŒ¨ìŠ¤
   3. ë°©ë¬¸ ì•ˆí–ˆë‹¤ë©´, ì´ë¥¼ ë°©ë¬¸ ë°°ì—´ì— ë„£ê³  ê·¸ ì •ì ê³¼ ì´ì–´ì§„ ì •ì ë“¤ì„ ë°°ì—´ì— ë‹¤ì‹œ ìŒ“ëŠ”ë‹¤.

```js
const graph = {
  A: ['B', 'C'],
  B: ['A', 'D'],
  C: ['A', 'G', 'H', 'I'],
  D: ['B', 'E', 'F'],
  E: ['D'],
  F: ['D'],
  G: ['C'],
  H: ['C'],
  I: ['C', 'J'],
  J: ['I']
};

const BFS = (graph, startNode) => {
  let visited = []; // íƒìƒ‰ì„ ë§ˆì¹œ ë…¸ë“œë“¤
  let needVisit = []; // íƒìƒ‰ í•´ì•¼í•  ë…¸ë“œë“¤

  needVisit.push(startNode);

  while (needVisit.length !== 0) {
    // íƒìƒ‰í•´ì•¼í•  ë…¸ë“œê°€ ë‚¨ì•„ìˆë‹¤ë©´
    const node = needVisit.shift(); // ê°€ì¥ ì˜¤ë˜ ë‚¨ì•„ìˆë˜ ì •ì ì„ ë½‘ì•„ëƒ„.
    if (!visited.includes(node)) {
      visited.push(node);
      needVisit = [...needVisit, ...graph[node]];
    }
  }
  return visited;
};

console.log(BFS(graph, 'A'));
```

BFS ë¥¼ í™œìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°

- ìµœë‹¨ ê±°ë¦¬ ë¬¸ì œ

**BFS ì™€ DFSì˜ ì‹œê°„ ë³µì¡ë„**
DFSì™€ BFSëŠ” ë…¸ë“œ ìˆ˜ + ê°„ì„  ìˆ˜ ë§Œí¼ì˜ ë³µì¡ë„ë¥¼ ì§€ë‹Œë‹¤. ì¦‰, O(n)
